<!DOCTYPE html>
<html>
  <head>
    <title>DJ 2040</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1>Introduction</h1>
    <h1>High Level Design</h1>
    <p>

      <!-- All the audio processing that occurs on the inputted sound is done in the
      frequency domain in order to be able to manipulate target frequencies.  Thus, a time-frequency transformation needed to be performed on the audio data streamed in from the ADC channel.  Additionally, the  -->
    </p>
    <h1>Hardware Design</h1>

    <h2>Audio Input</h2>
    <p>
      In order to receive audio data, sound from a computer is plugged into an
      audio connector breakout, allowing us to actually receive and use the
      analog voltages that correspond to the sound waves to be outputted. The
      voltage from one end of the audio connector (corresponding to either left
      or right in stereo audio) was used as the input to one of the ADC channels
      on the RP2040, allowing us to read in the analog voltages of the sound as
      it is played from a device. Becuase the ADC channel on the RP2040 requires
      a voltage between 0V and 3.3V, a voltage divider is used to hold the ADC
      pin at a mid-rail bias, and a series capacitor is placed in between the
      ADC conncection and the audio jack output in order to capture the correct
      analog voltage behavior centered around a 1.65V bias. This voltage divider
      and series capacitor also acts as a high pass filter with a break
      frequency at around 318 Hz. The filter does not significantly cut out the
      low frequencies until about 80 Hz (discovered by simply listening). Though
      we can still hear in a frequency range below 80 Hz, it is ultimately a
      very quiet range for us to hear, and concluded that it is not important to
      keep the frequencies below 318 Hz at unity gain.
    </p>
    <p>
      The design for the audio input network was inspired by the "<a
        href="https://ece4760.github.io/Projects/Fall2022/bat66_cys37_rjw252/index.html"
        target="_blank">Audio Spatializer</a>" project by Bianca Tseng, Crystal
      Shi, and Rosie Wildermuth in the Fall 2022 section of ECE 4760. Their
      implementation included a low pass filter at around 5 kHz to eliminate
      aliasing effects, but we chose not to implement this filter after finding
      that the there were no significnat audible artifacts when removing that
      low pass filter.
    </p>

    <h2>Audio Output</h2>
    <p>
      The final sound output after audio processing is accomplished using a
      12-bit digital to analog converter that communicates with the RP2040 using
      SPI. The DAC has the ability to produce audio for two separate audio
      channels, but because we are only using single-ended audio, only one of
      these channels is used. An additional audio jack connects to the DAC
      output in order to capture the analog voltages and transfer them into an
      audio cable connected to a speaker. Both ends of the audio connector are
      attached to the same DAC output channel in order to ensure mono audio.
    </p>
    <p>
      Unlike the input signal, the output to the audio connector does not need
      to be at a mid-rail bias because the software implementation places the DC
      bias of the signal in its middle range already. Placing the voltage levels
      in the software is advantageous because a mid-rail bias in hardware would
      inherently require filtering due to the need for an RC network.
    </p>
    <p>
      In an attempt to eliminate noise in the sound signal, a low pass filter
      was implemented around 12.5 kHz (which exactly matches the sampling
      frequency of the ADC). However, this low pass filter did not seem to
      eliminate any noise, but instead only contributed to volume attenuation.
      As a result, this low pass filter at the output was not used in the final
      design.
    </p>

    <h2>VGA Display</h2>

    <h2>Control Knobs</h2>
    <p>
      The control knobs are implemented using linear rotary potentiometers.
      Because we wanted the rotating of the potentiometers to have a linear
      relationship with the control scalars for the sound output, the peripheral
      circuitry invovled vor connecting the potentiometers is done in order to
      have a linear relationship between voltage at the ADC input channel and
      position of the pontentiometer's position.
    </p>
    <p>
      Figure X displays the schematic used for setting up the potentiometer
      control knobs. The non-inverting amplifier circuit creates a gain of A = 1
      + R<sub>f</sub> / R<sub>i</sub>. Thus, with a linear rotary potentiometer
      as the amplifier's feedback resistor (where the resistance is linear with
      respect to potentiometer position), the output voltage of the amplifier
      will also be linear with respect to potentiometer position. The voltage
      seen by the ADC for each control knob will then be use to process the
      audio that the RP2040 receives, which will be discussed further in the
      Software Design section. Additionally, with an input voltage of 1V to the
      amplifier, the gain is a measure of the voltage seen by the ADC channel:
      (1 + R<sub>f</sub> / R<sub>i</sub>) Volts.
    </p>
    <p>
      The maximum gain for this amplifier was chosen such that the op-amp used
      and the RP2040's ADC channel could both handle the dynamic range that the
      amplilfier will provide. Firstly, the LM358 op-amp used for this circuit
      is not a rail-to-rail amplifier, and thus can only provide a voltage up to
      1.42V lower than its positive supply voltage, and 100mV greater than its
      negative supply voltage. With a negative supply voltage at ground, this
      means that the output voltage should not ever go below 100mV.
      Additionally, the requirements of the RP2040 ADC channel indicate that the
      voltage should not exceed 3.3V, since the voltage reference for the ADC
      channels will cause the channel to saturate at 3.3V, and any readings
      above that voltage will not be able to be read. As a result, the maximum
      output voltage of the amplifier was held to be 3V, which gives a dynamic
      range of 1 to 3 volts that the amplifier output can range between. This 3V
      maximum is suitable for the op-amp specifciations because it is well below
      the 1.42V below the supply voltage (using a 5V supply voltage from the
      RP2040). In order to acheive this dynamic range, we consider that the
      maximum resistance of the potentiometer is 10kΩ, and the minium resistance
      is 0Ω. Using the voltage equation, we can already see that when the
      resistance of the potentiometer is at its minimum, the output votlage will
      be 1V. As a result, the resistance R<sub>i</sub> must be set such that the
      maximum resistance of the potentiometer matches the maximum voltage we
      want to be outputted, which is 3V. We can find this resistance by
      rearranging the voltage equation:
    </p>
    <p>
      1 + R<sub>f</sub> / R<sub>i</sub> = 3
    </p>
    <p>
      (1 + R<sub>f</sub>) / 3 = R<sub>i</sub>
    </p>
    <h1>Software Design</h1>
    <h2>Audio Processing</h2>
    <h2>ISR and Protothread Semaphores</h2>

    <p>
   The repeating timer callback function is set to trigger every 80 microseconds. 
   In the interrupt service routine (ISR), we first check if our interrupt index (interrupt_idx) 
   is less than the number of samples taken for the FFT. If it is, we then read ADC Channel 0 and 
   store the value in the fft_buff_r array at the position specified by interrupt_idx. In the fft_buff_i 
   array, at the position specified by interrupt_idx, we store a 0. Finally, we increment the interrupt_idx 
   variable to move to the next position in the array. If the interrupt_idx is greater than or equal to the 
   number of samples taken for the FFT, we use memcpy to copy the contents of the fft_buf_r array into the 
   fr array. Likewise, we use memcpy to copy the contents of the fft_buff_i array into the fi array. We 
   then reset the interrupt_idx back to 0, and using semaphores, we signal to the protothread_fft that the next frame 
   is ready to be processed.
   <\p>
<p>
   Additionally, in the ISR we begin sending the altered audio frame to the DAC. We do this by setting the 
   variable sound to the value of the interrupt_fft_array at the position of sound_idx. We then increment 
   sound_idx and check if it is greater than or equal to the total number of samples taken for the FFT. If 
   it is, sound_idx is reset back to 0 and we signal with the load_sempahore that the prior frame has been 
   outputted and we can move onto the next frame. Lastly, we need to output values to the DAC. We first take 
   the sound variable and multiply it by 2, and then shit it up by 2048 in order to be in the acceptable range
   for the DAC. This value is then masked with DAC_config_chan_A for DAC_data_1 and DAC_config_chan_B for DAC_data_0. 
   We then transmit the data using SPI. 
<\p>
    <h2>VGA Graphics</h2>
    <h1>Results</h1>
    <h1>Conclusions</h1>
    <div id="appendices">
      <h1>Appendix A: Permissions</h1>
      <h1>Appendix B: Code</h1>
      <h1>Appendix C: Schematics</h2>
      <img src="images/audio_in_schematic.png" id="audio_in">
      <img src="images/audio_out_schematic.png" id="audio_out">
      <h1>Appendix D: Tasks</h1>
      <h1>Appendix E: References</h1>
    </div>
  </body>
</html>
